<html>
<head>
<style type="text/css">
	html,body{
		height: 100%;
		width: 100%;
		margin: 0;
		padding: 0;
	}
	#main{
		height: 100%;
		height: 100%;
	}
</style>
</head>
<body>
<div id="main">
	
</div>
<script type="text/javascript" src="../src/lib/require.js"></script>
<script type="text/javascript" src="../src/lib/zrender.js"></script>
<script type="text/javascript">
define('custom/shape/TaskBlock',[
            'zrender/graphic/shape/Polygon',
            'zrender/graphic/shape/Rect',
            'zrender/graphic/shape/Circle',
            'zrender/container/Group',
            'zrender/graphic/Text',
            'zrender/core/util'
        ], 
function (Polygon, Rect, Circle, Group, ZText, util) {
	
	function TaskBlock (zr, opt) {
		this._zr = zr;
		this._init(opt);
	}

	TaskBlock.prototype = {
		_init: function(opt) {
			var source = {
				radius: 5, // 矩形周围的线柱半径
				width: 100, // 矩形的宽
			    height: 100, // 矩形的高
			    r: 4, // 矩形的圆角半径
			    x: 100, // 矩形的起始x
			    y: 100, // 矩形的起始y
			    start: false,
			    end: false,
			    style: {}
			};
			var that = this;
			if(!opt){
				//opt = source;
			}else{
				util.extend(source, opt);
			}
			var group = new Group();
			var rect, child;
			if(source.start) {
				rect = new Polygon({
					shape: {
			            points: [
			            	[source.x + source.width/2, source.y], 
			            	[source.x + source.width, source.y + source.height/2],
			            	[source.x + source.width/2, source.y + source.height],
			            	[source.x, source.y + source.height/2]
			            ],
            			smooth: 'spline',
			        },
			        style: source.style,
			        draggable: true,
				});
			} else if (source.end) {
				rect = new Polygon({
					shape: {
			            points: [
			            	[source.x + source.width/2, source.y], 
			            	[source.x + source.width, source.y + source.height/2],
			            	[source.x + source.width/2, source.y + source.height],
			            	[source.x, source.y + source.height/2]
			            ],
            			smooth: 'spline',
			        },
			        style: source.style,
			        draggable: true,
				});
			} else {
				rect = new Rect({
					shape: {
			            r: source.r,
			            x: source.x,
			            y: source.y,
			            width: source.width,
			            height: source.height
			        },
			        style: source.style,
			        draggable: true,
				});
				child = new Rect({
					shape: {
			            r: source.r,
			            x: source.x,
			            y: source.y,
			            width: source.width,
			            height: 20
			        },
			        style: {
			        	fill: '#b9c7da',
			        	stroke: '#333',
			        	text: source.title,
			        	textFill: '#000'
			        },
				})
			}
			var rectCaps = [];
			var rectCapsPos = function (x, y) {
				var arr = [];
				arr.push({
					x: source.x + source.width/2,
					y: source.y - source.radius - 3,
					dir: 'top'
				});
				arr.push({
					x: source.x + source.width + source.radius + 3 ,
					y: source.y + source.height/2,
					dir: 'right'
				});
				arr.push({
					x: source.x + source.width/2,
					y: source.y + source.height + source.radius + 3,
					dir: 'bottom'
				});
				arr.push({
					x: source.x - source.radius - 3,
					y: source.y + source.height/2,
					dir: 'left'
				});
				return arr;
			};
			for(var i=0,arr=rectCapsPos(source.x, source.y);i<arr.length;i++){
				var circle = new Circle({
					shape:{
						cx: arr[i].x,
			            cy: arr[i].y,
			            r: source.radius
			        },
			        style: {
			        	fill: !!(source.start || source.end ) ? '#7373f5' : '#735151'
			        }
				});
				circle.dir = arr[i].dir;
				circle.zlevel = 100;
				circle.follow = rect;
				circle.shape_cp = util.clone(circle.shape);
				group.add(circle);
				rectCaps.push(circle);
			}
			rect.on('drag', function(){
				if(child) child.transform = this.transform;
				for(var i=0;i<rectCaps.length;i++){
					rectCaps[i].setShape('cx', this.position[0] + rectCaps[i].shape_cp.cx);
					rectCaps[i].setShape('cy', this.position[1] + rectCaps[i].shape_cp.cy);

				}
			})
			group.add(rect);
			group.add(child);
			this._zr.add(group);
			this._rectCaps = rectCaps;
			this._rect = rect;
		},
		getPointObj: function() {
			return this._rectCaps;
		},
		getRect: function() {
			return this._rect;
		}
	}
	return TaskBlock;
})

define('custom/action/lineTo', ['custom/shape/TaskBlock', 'zrender/graphic/shape/Polyline', 'zrender/core/util'], function(TaskBlock, Polyline, util) {
	function LineTo(zr, task, lineCache, helpLine) {
		this._init(zr, task, lineCache, helpLine);
	}
	LineTo.prototype = {
		constructor: LineTo,

		_init: function(zr, task, lineCache, helpLine) {
			this._zr = zr;
			this._task = task;
			this._lineCache = lineCache;
			this._helpLine = helpLine;
			this._initElement();
		},
		drawLine: function (start, end) {
			var pline = new Polyline({
				shape: {
					points: [[start.shape.cx + start.position[0], start.shape.cy + start.position[1]], [end.shape.cx + end.position[0], end.shape.cy + end.position[1]]],
				}
			})
			start.follow.on('drag', function(){
				var x1 = start.position[0] + start.shape.cx;
				var y1 = start.position[1] + start.shape.cy;
				var points = pline.shape.points;
				points[0] = [x1, y1];
				pline.setShape('points', points);
			})
			end.follow.on('drag', function(){
				var x1 = end.position[0] + end.shape.cx;
				var y1 = end.position[1] + end.shape.cy;
				var points = pline.shape.points;
				points[1] = [x1, y1];
				pline.setShape('points', points);
			})
			this._zr.add(pline);
		},
		_initElement: function () {
			var that = this;
			this._zr.on("mouseup", function (e) {
				that._helpLine.setShape('x1', 0);
				that._helpLine.setShape('x2', 0);
				that._helpLine.setShape('y1', 0);
				that._helpLine.setShape('y2', 0);
				that._lineCache.status = false;
			});
			
			this._zr.on("mousemove", function(e) {
				if(!that._lineCache.status) return;
				that._helpLine.setShape('x2',e.offsetX);
				that._helpLine.setShape('y2',e.offsetY);
			});

			var points = this._task.getPointObj();
			/* 点的拖动 start */
			util.each(points, function(point) {
				point.on("mousedown", function(e) {
					that._lineCache.start = point;
					that._lineCache.status = true;
					that._lineCache.context = that._task;
					that._helpLine.setShape('x1', point.shape.cx);
					that._helpLine.setShape('x2', point.shape.cx);
					that._helpLine.setShape('y1', point.shape.cy);
					that._helpLine.setShape('y2', point.shape.cy);
				})
				
				point.on("mouseup", function(e) {
					if(that._lineCache.status && that._lineCache.context != that._task) {				
						that._lineCache.end = point;
						that.drawLine(that._lineCache.start, that._lineCache.end);
					}
					that._helpLine.setShape('x1', 0);
					that._helpLine.setShape('x2', 0);
					that._helpLine.setShape('y1', 0);
					that._helpLine.setShape('y2', 0);
				})
			})
		}
	}

	return LineTo;
	/*
	return function (zr, task, lineCache, helpLine) { 
		
		function drawLine (start, end) {
			var pline = new Polyline({
				shape: {
					points: [[start.shape.cx + start.position[0], start.shape.cy + start.position[1]], [end.shape.cx + end.position[0], end.shape.cy + end.position[1]]],
				}
			})
			start.follow.on('drag', function(){
				var x1 = start.position[0] + start.shape.cx;
				var y1 = start.position[1] + start.shape.cy;
				var points = pline.shape.points;
				points[0] = [x1, y1];
				pline.setShape('points', points);
			})
			end.follow.on('drag', function(){
				var x1 = end.position[0] + end.shape.cx;
				var y1 = end.position[1] + end.shape.cy;
				var points = pline.shape.points;
				points[1] = [x1, y1];
				pline.setShape('points', points);
			})
			zr.add(pline);

		}
		// 点的拖动 end
		console.log(this);
	}
	*/
})
require(['zrender', 'zrender/graphic/shape/Line', 'custom/shape/TaskBlock', 'custom/action/lineTo'],
function (zrender, Line, TaskBlock, LineTo){
	var zr = zrender.init(document.getElementById("main"));
	
	var start = new TaskBlock(zr, {
									x: 400, 
									y: 50, 
									start: true, 
									width: 50, 
									height: 50,
									style: {
										fill: '#18a689',
										text: 'Start',
										textFill: '#fff'
									}
								});
	var task = new TaskBlock(zr, {
									x: 375, 
									y: 200, 
									width: 100, 
									height: 60, 
									title: '用户任务',
									style: {
										fill: '#fff',
										text: '1fefwfwfwxgch\nkdadalj',
										textOffset: [0, 5],
										stroke: '#333'
									}
								});
	var end = new TaskBlock(zr, {
									x: 400, 
									y: 350, 
									end: true, 
									width: 50, 
									height: 50,
									style: {
										text: 'End',
										textFill: '#fff',
										fontWeight: '600',
										fill: '#cb3103',
									}
								});
	// 全局控制连线的容器
	var lineCache = {
		start: null,
		end: null,
		status: false, //判断鼠标是否按下
		context: ''//父容器
	};
	// 辅助线
	var helpLine = new Line({
		shape:{
			x1: 0,
			y1: 0,
			x2: 0,
			y2: 0
		}
	});
	zr.add(helpLine);
	// 开启连线
	new LineTo(zr, start, lineCache, helpLine).drawLine(start.getPointObj()[2], task.getPointObj()[0]);
	new LineTo(zr, task, lineCache, helpLine).drawLine(task.getPointObj()[2], end.getPointObj()[0]);
	new LineTo(zr, end, lineCache, helpLine);
})
</script>
</body>
</html>