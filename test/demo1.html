<html>
<head>
<style type="text/css">
	html,body{
		height: 100%;
		width: 100%;
		margin: 0;
		padding: 0;
	}
	#main{
		height: 100%;
		height: 100%;
	}
</style>
</head>
<body>
<div id="main">
	
</div>
<script type="text/javascript" src="../src/lib/require.js"></script>
<script type="text/javascript" src="../src/lib/zrender.js"></script>
<script type="text/javascript">
define('TaskBlock',[
            'zrender/graphic/shape/Polygon',
            'zrender/graphic/shape/Rect',
            'zrender/graphic/shape/Circle',
            'zrender/container/Group',
            'zrender/graphic/Text',
            'zrender/core/util'
        ], 
function (Polygon, Rect, Circle, Group, ZText, util) {
	
	function TaskBlock (zr, opt) {
		this._zr = zr;
		this._init(opt);
	}

	TaskBlock.prototype = {
		_init: function(opt) {
			var source = {
				radius: 5, // 矩形周围的线柱半径
				width: 100, // 矩形的宽
			    height: 60, // 矩形的高
			    r: 4, // 矩形的圆角半径
			    x: 100, // 矩形的起始x
			    y: 100 // 矩形的起始y
			}
			if(!opt){
				opt = source;
			}else{
				util.extend(source, opt);
			}
			var group = new Group();
			var rect = new Rect({
				shape: {
		            r: source.r,
		            x: source.x,
		            y: source.y,
		            width: source.width,
		            height: source.height
		        },
		        draggable: true
			});
			var rectCaps = [];
			var rectCapsPos = function (x, y) {
				var arr = [];
				arr.push({
					x: source.x + source.width/2,
					y: source.y - source.radius - 3,
				});
				arr.push({
					x: source.x + source.width + source.radius + 3 ,
					y: source.y + source.height/2,
				});
				arr.push({
					x: source.x + source.width/2,
					y: source.y + source.height + source.radius + 3,
				});
				arr.push({
					x: source.x - source.radius - 3,
					y: source.y + source.height/2,
				});
				return arr;
			};
			for(var i=0,arr=rectCapsPos(source.x, source.y);i<arr.length;i++){
				var circle = new Circle({
					shape:{
						cx: arr[i].x,
			            cy: arr[i].y,
			            r: source.radius
			        }
				});
				group.add(circle);
				rectCaps.push(circle);
			}
			rect.on('drag', function(){
				/*
				var curPositon = this.position,
					orignPosition = [this.shape.x, this.shape.y];
				var postion = [orignPosition[0] + curPositon[0], orignPosition[1] + curPositon[1], this.shape.width, this.shape.height];
				*/
				for(var i=0;i<rectCaps.length;i++){
					rectCaps[i].transform = this.transform;
				}
			})
			group.add(rect);
			this._zr.add(group);
			this._rectCaps = rectCaps;
			this._rect = rect;
		},
		getPointObj: function() {
			return this._rectCaps;
		},
		getRect: function() {
			return this._rect;
		}
	}
	return TaskBlock;
})

require(['zrender','TaskBlock', 'zrender/graphic/shape/Polyline'], function(zrender, TaskBlock, Polyline) {
	var zr = zrender.init(document.getElementById("main"));
	var task1 = new TaskBlock(zr, {x: 100, y: 100});
	var task2 = new TaskBlock(zr, {x: 600, y: 200});

	var points1 = task1.getPointObj();

	var points2 = task2.getPointObj();

	var start = points1[1];
	var end = points2[3];

	var pline = new Polyline({
		shape: {
			points: [[start.shape.cx, start.shape.cy], [end.shape.cx, end.shape.cy]],
		}
	})
	start.pline = pline;
	var rect = task1.getRect();
	rect.on('drag', function(){
		var pline = new Polyline({
			shape: {
				points: [[start.shape.cx + start.transform[4] , start.shape.cy + start.transform[5]], [end.shape.cx, end.shape.cy]],
			}
		})
		zr.remove(start.pline);
		zr.add(pline);
		start.pline = pline;

	})
	zr.add(pline);
})
</script>
</body>
</html>